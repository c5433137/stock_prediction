package logic

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)
//用如下结构体，存储每日行情数据
type Autogenerated struct {
	ShowapiResError string `json:"showapi_res_error"`
	ShowapiResID    string `json:"showapi_res_id"`
	ShowapiResCode  int    `json:"showapi_res_code"`
	ShowapiResBody  struct {
		RetCode int `json:"ret_code"`
		List  []CodeList   `json:"list"`
	} `json:"showapi_res_body"`
}
type CodeList struct {
	//TradeMoney string `json:"trade_money"`
	//DiffMoney string `json:"diff_money"`

	Code string `json:"code"`
	OpenPrice string `json:"open_price"` //开盘价
	Date string `json:"date"`
	Market string `json:"market"`
	MinPrice string `json:"min_price"`
	//TradeNum string `json:"trade_num"`
	//Turnover string `json:"turnover"`
	ClosePrice string `json:"close_price"`
	MaxPrice string `json:"max_price"`
	//Swing string `json:"swing"`
	//DiffRate string `json:"diff_rate"`
}

func (c CodeList)Convert()CodeListNewType  {
	t:=CodeListNewType{}
	//t.TradeMoney,_=strconv.ParseFloat(c.TradeMoney,64)
	//t.DiffMoney,_=strconv.ParseFloat(c.DiffMoney,64)
	t.Code=c.Code
	t.OpenPrice,_=strconv.ParseFloat(c.OpenPrice,64)
	t.Date,_=strconv.Atoi(strings.Replace(c.Date,"-","",-1))
	t.Market=c.Market
	t.MinPrice,_=strconv.ParseFloat(c.MinPrice,64)
	//TradeNum,_:=strconv.Atoi(c.TradeNum)
	//t.TradeNum=int64(TradeNum)
	//t.Turnover,_=strconv.ParseFloat(c.Turnover,64)
	t.ClosePrice,_=strconv.ParseFloat(c.ClosePrice,64)
	t.MaxPrice,_=strconv.ParseFloat(c.MaxPrice,64)
	//t.Swing,_=strconv.ParseFloat(c.Swing,64)
	//t.DiffRate,_=strconv.ParseFloat(c.DiffRate,64)
	return t
}
type CodeListNewType struct {
	//TradeMoney float64 `json:"trade_money"`
	//DiffMoney float64 `json:"diff_money"`
	Code string `json:"code"`
	OpenPrice float64 `json:"open_price"` //开盘价
	Date int `json:"date"`
	Market string `json:"market"`
	MinPrice float64 `json:"min_price"`
	//TradeNum int64 `json:"trade_num"`
	//Turnover float64 `json:"turnover"`
	ClosePrice float64 `json:"close_price"`
	MaxPrice float64 `json:"max_price"`
	//Swing float64 `json:"swing"`
	//DiffRate float64 `json:"diff_rate"`
}

type CodeListNewTypeSort []CodeListNewType

func (c CodeListNewTypeSort) Len() int {
	return len(c)
}

func (c CodeListNewTypeSort) Less(i, j int) bool {
	return c[i].Date<c[j].Date

}

func (c CodeListNewTypeSort) Swap(i, j int) {
	c[i],c[j]=c[j],c[i]
}


//急速api
type AutoGenerated struct {
	Status int `json:"status"`
	Msg string `json:"msg"`
	Result Result `json:"result"`
}
type List struct {
	ID int `json:"id"`
	Stockid int `json:"stockid"`
	Date string `json:"date"`
	Openningprice string `json:"openningprice"`
	Closingprice string `json:"closingprice"`
	Maxprice string `json:"maxprice"`
	Minprice string `json:"minprice"`
	Tradenum int `json:"tradenum"`
	Tradeamount string `json:"tradeamount"`
	Turnoverrate string `json:"turnoverrate"`
	Changepercent string `json:"changepercent"`
	Changeamount string `json:"changeamount"`
	Amplitude string `json:"amplitude"`
	Per interface{} `json:"per"`
	Pbr interface{} `json:"pbr"`
	Totalmarket interface{} `json:"totalmarket"`
	Circulationmarket interface{} `json:"circulationmarket"`
}
type Result struct {
	Code      string `json:"code"`
	Name      string `json:"name"`
	Startdate string `json:"startdate"`
	Enddate   string `json:"enddate"`
	List []List `json:"list"`
}
func (c List)Convert()CodeListNewType  {
	t:=CodeListNewType{}
	//t.TradeMoney,_=strconv.ParseFloat(c.TradeMoney,64)
	//t.DiffMoney,_=strconv.ParseFloat(c.DiffMoney,64)
	t.Code=strconv.Itoa(c.Stockid)
	t.OpenPrice,_=strconv.ParseFloat(c.Openningprice,64)
	t.Date,_=strconv.Atoi(strings.Replace(c.Date,"-","",-1))
	//t.Market=c.Totalmarket
	t.MinPrice,_=strconv.ParseFloat(c.Minprice,64)
	//TradeNum,_:=strconv.Atoi(c.TradeNum)
	//t.TradeNum=int64(TradeNum)
	//t.Turnover,_=strconv.ParseFloat(c.Turnover,64)
	t.ClosePrice,_=strconv.ParseFloat(c.Closingprice,64)
	t.MaxPrice,_=strconv.ParseFloat(c.Maxprice,64)
	//t.Swing,_=strconv.ParseFloat(c.Swing,64)
	//t.DiffRate,_=strconv.ParseFloat(c.DiffRate,64)
	return t
}
func getStockDataByJisu(stockId,start,end string)[]CodeListNewType  {

	url := "http://api.jisuapi.com/stockhistory/query"
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		panic(err)
	}
	req.Header.Add("Content-Type", "application/json;charset=UTF-8")
	//bce-auth-v1/{accessKey}/{timestamp} /{expirationPeriodInSeconds}/{signedHeaders}/{signature}
	query := req.URL.Query()


	query.Add("code", stockId)
	query.Add("startdate", start)
	query.Add("enddate", end)
	query.Add("appkey",os.Getenv("appkey"))
	//query.Add("type", "qfq")//前复权数据

	req.URL.RawQuery = query.Encode()

	fmt.Println(req.RequestURI,"------: ",req.URL.Path,req.URL.RawQuery)
	fmt.Println(req.Header)
	client := &http.Client{}
	req.Method=http.MethodGet

	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	fmt.Println("Response status: ", resp.Status)
	fmt.Println("Response headers: ", resp.Header)
	respBody, _ := ioutil.ReadAll(resp.Body)
	fmt.Println("Response body: ", string(respBody))
	res:=&AutoGenerated{}
	var resNew = make([]CodeListNewType,0, len(res.Result.List))
	err = json.Unmarshal(respBody,res)
	if err != nil{
		return  resNew
	}

	for _,v:=range res.Result.List{
		resNew=append(resNew,v.Convert())
	}
	return resNew
}













	/////////百度api


const (
	appCode = ""
	accessKey = ""
	secretKey = ""
)
func hmacSha256(secret string, data string) string {
	h := hmac.New(sha256.New, []byte(secret))
	h.Write([]byte(data))
	return hex.EncodeToString(h.Sum(nil))
}
func calSign(src string,expire int) string {
	//服务器时区有问题 坑 容器的时区能对上不用改  304问题  502是时间周期太长
	tstr:=time.Now().Add(time.Hour*-8*1).Format("2006-01-02T15:04:05Z")

	//tstr="2021-05-15T18:17:28Z"
	authStringPrefix:=fmt.Sprintf("bce-auth-v1/%s/%s/%d",accessKey,tstr,expire)
	//待签名字符串
	signingKey:=hmacSha256(secretKey, authStringPrefix)
	signature := hmacSha256(signingKey, src)
	return  fmt.Sprintf("%s/%s/%s",authStringPrefix,"host",signature)
}
func getSrc(method,uri,params,head string) string {
	//params=url.QueryEscape(params)
	return fmt.Sprintf(`%s
%s
%s
%s`,method,uri,params,head)//和\n有区别
}
func getStockDataByBaidu(stockId,start,end string)[]CodeListNewType  {
	h:="stocks.api.bdymkt.com"
	url := "http://stocks.api.bdymkt.com/stockHistoryK"
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		panic(err)
	}
	req.Header.Add("Content-Type", "application/json;charset=UTF-8")
	//bce-auth-v1/{accessKey}/{timestamp} /{expirationPeriodInSeconds}/{signedHeaders}/{signature}
	query := req.URL.Query()

	query.Add("begin", start)
	query.Add("code", stockId)
	query.Add("end", end)
	query.Add("type", "qfq")//前复权数据

	req.URL.RawQuery = query.Encode()
	src:=getSrc(http.MethodGet,req.URL.Path,req.URL.RawQuery,fmt.Sprintf("host:%s",h))
	sign:=calSign(src,1800)
	//fmt.Println(strings.EqualFold(sign,
	//	"bce-auth-v1/eaeb1f2f1aff4ac0bdcd1be6ec5fcdc0/2021-05-15T18:17:28Z/10000/host/27e1e9b764d22b975d9c8b3555efb9e74c6f6ce60a98bbf3cc37323ead3b56a1"))
	req.Header.Add("X-Bce-Signature", sign)
	req.Header.Add("Host", h)
	//req.Header.Add("X-Bce-Signature", fmt.Sprintf("AppCode/%s",appCode))
	fmt.Println(req.RequestURI,"------: ",req.URL.Path,req.URL.RawQuery)
	fmt.Println(req.Header)
	client := &http.Client{}
	req.Method=http.MethodGet

	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	fmt.Println("Response status: ", resp.Status)
	fmt.Println("Response headers: ", resp.Header)
	respBody, _ := ioutil.ReadAll(resp.Body)
	fmt.Println("Response body: ", string(respBody))
	res:=&Autogenerated{}
	err = json.Unmarshal(respBody,res)
	if err != nil{
		panic(err)
	}
	var resNew = make([]CodeListNewType,0, len(res.ShowapiResBody.List))
	for _,v:=range res.ShowapiResBody.List{
		resNew=append(resNew,v.Convert())
	}
	return resNew
}










var dateForm = "20060102"
func GetStockData(stockId string)[]CodeListNewType  {
	date:=time.Now().Format("2006-01-02")
	f, err := os.OpenFile(fmt.Sprintf("%s_%s.json",date,stockId), os.O_CREATE|os.O_RDWR, 0644) // 创建一个log日志文件
	if err != nil {
		return nil
	}
	defer f.Close()
	d,err:=ioutil.ReadAll(f)
	if err != nil {
		return nil
	}
	var res []CodeListNewType
	err = json.Unmarshal(d,&res)
	if err !=nil || len(res)==0{
		T:=30
		n:=3
		t:=time.Now().AddDate(0,0,n*T*-1)
		for i:=n;i>=1;i--{
			start:=t.Format(dateForm)
			t=t.AddDate(0,0,T*1)
			end:=t.Format(dateForm)
			t=t.AddDate(0,0,1)//去除重复的一天

			res = append(res,reverse(getStockData(stockId,start,end))...)
		}
		//sort
		sort.Sort(CodeListNewTypeSort(res))
		_res,_:=json.Marshal(res)
		f.Write(_res)
		return res
	}else{
		return res
	}
}
func reverse(s []CodeListNewType) []CodeListNewType {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
	return s
}



//区间跨度太大会报错
func getStockData(stockId,start,end string)[]CodeListNewType  {
	//res:=getStockDataByBaidu(stockId,start,end)
	res:=getStockDataByJisu(stockId,start,end)
	return res
}











func (c *CodeList)convertSliceFloat()[]float64  {
	OpenPrice,_:=strconv.ParseFloat(c.OpenPrice,64)
	ClosePrice,_:=strconv.ParseFloat(c.ClosePrice,64)
	MinPrice,_:=strconv.ParseFloat(c.MinPrice,64)
	MaxPrice,_:=strconv.ParseFloat(c.MaxPrice,64)
	return []float64{
		OpenPrice,
		ClosePrice,
		MinPrice,
		MaxPrice,
	}
}
func (c *CodeListNewType)convertSliceFloat()[]float64  {
	return []float64{
		c.OpenPrice,
		c.ClosePrice,
		c.MinPrice,
		c.MaxPrice,
	}
}
